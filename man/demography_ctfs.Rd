% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/demography_ctfs.R
\name{demography_ctfs}
\alias{demography_ctfs}
\alias{recruitment_ctfs}
\alias{mortality_impl}
\alias{mortality_ctfs}
\alias{growth_impl}
\alias{growth_ctfs}
\title{Recruitment, mortality, and growth.}
\usage{
recruitment_ctfs(census1, census2, mindbh = NULL, alivecode = NULL,
  split1 = NULL, split2 = NULL, quiet = FALSE)

mortality_impl(census1, census2, alivecode = NULL, split1 = NULL,
  split2 = NULL, quiet = FALSE)

mortality_ctfs(census1, census2, alivecode = NULL, split1 = NULL,
  split2 = NULL, quiet = FALSE)

growth_impl(census1, census2, rounddown = FALSE, method = "I",
  stdev = FALSE, dbhunit = "mm", mindbh = NULL, growthcol = "dbh",
  err.limit = 1000, maxgrow = 1000, split1 = NULL, split2 = NULL,
  quiet = FALSE)

growth_ctfs(census1, census2, rounddown = FALSE, method = "I",
  stdev = FALSE, dbhunit = "mm", mindbh = NULL, growthcol = "dbh",
  err.limit = 1000, maxgrow = 1000, split1 = NULL, split2 = NULL,
  quiet = FALSE)
}
\arguments{
\item{census1, census2}{Two census tables, each being a dataframe and in
particular, a ForestGEO tree table. You may use a stem table, but you more
commonly should use a tree table because demography analyses make more
sense at the scale of a tree than at the scale of stems.}

\item{mindbh}{The minimum diameter above which the counts are done. Trees
smaller than `mindbh` are excluded. If `NULL`, all living trees are
included.}

\item{alivecode}{Character, codes of the variable `status` that indicate the
tree is alive. The default 'A' is the standard CTFS designation for living
trees or stems.}

\item{split1, split2}{Optional vectors (column of any one the census
dataframe) to aggregate results by. Defaults to aggregating across the
entire census datasets.}

\item{quiet}{Use `TRUE` to suppress messages.}

\item{rounddown}{If `TRUE`, all `dbh < 55` are rounded down to the nearest
multiple of 5.}

\item{method}{Use "I" to calculate annual dbh increment as
`(dbh2 - dbh1)/time`, or "E" to calculate the relative growth rate as
`(log(dbh2) - log(dbh1)) / time`.}

\item{stdev}{Logical. Default (`FALSE`) returns confidence limits, otherwise
returns the SD in growth rate per group.}

\item{dbhunit}{'cm' or 'mm'.}

\item{growthcol}{defines how growth is measured, either 'dbh' or 'agb'
(above ground biomass).}

\item{err.limit}{A number. Numbers such as 10000 are high and will return all
measures.}

\item{maxgrow}{A number. Numbers such as 10000 are high and will return all
measures.}
}
\value{
Metrics of recruitment: Similar to metrics of mortality.

Metrics of mortality:
* `N`: the number of individuals alive in the census 1 per category
  selected.
* `D`: the number of individuals no longer alive in census 2.
* `rate`: the mean annualized mortality rate constant per category
  selected, calculated as (log(N)-log(S))/time.
* `upper`: upper confidence limit of mean rate.
* `lower`: lower confidence limit of mean rate.
* `time`: mean time interval in years.
* `date1`: mean date included individuals were measured in census 1, as
  julian object (R displays as date, but treats as integer).
* `date2`: mean date in census 2.
* `dbhmean`: mean dbh in census 1 of individuals included.

Metrics of growth:
* `rate`, the mean annualized growth rate per category selected, either dbh
  increment, or relative growth
* `N`, the number of individuals included in the mean (not counting any
  excluded)
* `clim` (or sd with `stdev = TRUE`), width of confidence interval; add this
  number to the mean rate to get upper confidence limit, substract to get
  lower
* `dbhmean`, mean dbh in census 1 of individuals included
* `time`, mean time interval in years
* `date1`, mean date included individuals were measured in census 1, as
  julian object (R displays as date, but treats as integer)
* `date2`, mean date in census 2.
}
\description{
These functions are inherited from the the CTFS-R package. Compared to the
original functions, these ones have a similar interface but use more
conservative defaults and allow suppressing messages. These functions also
feature formal tests, bug fixes, additional assertions, and improved
messages. (These functions are the internal implementation of their
in-development analogs -- hence the suffix `_impl`.)
}
\details{
Survivors are all individuals alive in both censuses, with `status == A` in
the first census, and larger than the minimum dbh in the first census. The
total population in the second census includes all those alive plus any other
survivors. Individuals whose status is NA in either census are deleted from
all calculations.
}
\examples{
census1 <- fgeo.x::tree5
census2 <- fgeo.x::tree6

recruitment_ctfs(census1, census2)

# Demography by any number of grouping variables via `interaction(...)`
sp_quadrat <- interaction(census1$sp, census1$quadrat)

recruitment <- recruitment_ctfs(
  census1, census2,
  split1 = sp_quadrat,
  quiet = TRUE
)
lapply(recruitment, head)

mortality <- mortality_ctfs(
  census1, census2, split1 = sp_quadrat, quiet = TRUE
)
lapply(mortality, head)

growth <- growth_ctfs(census1, census2, split1 = sp_quadrat, quiet = TRUE)
lapply(growth, head)

\dontrun{
# Convert to convenient dataframes -------------------------------------
is_installed <- requireNamespace("tidyr")
if (is_installed) {
  library(tidyr)

  to_df(
    recruitment_ctfs(census1, census2, quiet = TRUE)
  )

  to_df(mortality)

  separate(
    to_df(growth),
    groups, into = c("sp", "quadrat")
  )
}
}
}
\author{
Rick Condit, Suzanne Lao.
}
\concept{demography functions}
\concept{functions for ForestGEO data.}
\concept{functions for fgeo census.}
