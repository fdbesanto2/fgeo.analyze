% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighbor.R
\name{neighbor}
\alias{neighbor}
\alias{abundance_neighbor}
\alias{basal_area_neighbor}
\title{Count and basal area of neighboring stems, optionally by groups.}
\usage{
abundance_neighbor(.data, .subset = NULL, r, plotdim = NULL)

basal_area_neighbor(.data, .subset = NULL, r, plotdim = NULL)
}
\arguments{
\item{.data}{A Dataframe; particularly  a ForestGEO tree table.}

\item{.subset}{An optional dataframe giving the (`gx`, `gy`) coordinates of
specific individuals (`tag` and `sp`) for which to count neighbors. For
example, `.subset` may be a subset of only one species; or seedling that
are not part of census `.data`. `.subset` must have columns `gx`, `gy`,
`sp`, and `tag`.}

\item{r}{Radius.}

\item{plotdim}{The x and y dimensions of the plot.}
}
\value{
A dataframe.

A dataframe with two columns `conspecific` and `heterospecific`, and
optionally one extra column for each variable used to group by. The number
of rows is as follows:
* If `.subset` is `NULL`, the output and `.data` have equal number of rows,
both for grouped and ungrouped `.data`.
* If `.subset` is not `NULL`, and `.data` is ungrouped, the output and
`.subset` have equal number of rows.
* If `.subset` is not `NULL`, and `.data` is grouped, the output has a number
of rows that equals that of `.subset` multiplied by the number of groups.
}
\description{
`count_neighbour()` and `basal_area_neighbour()` output the same result as
`NeighborDensities()` from the CTFS-R package with the argument `type =
"count"` and `type = "basal"`, respectively. Compared to
`NeighborDensities()`, the main difference is that these functions throw more
informative warnings and error messages, and have simpler interfaces. They
don't deal with dbh or status, meaning that you should pick the values you
want before using these functions. And they allow you to compute by groups
created with [dplyr::group_by()].
}
\section{Warning}{

This function has a pending issue by which a dataset with a single row does
not result in zero conspecific neighbors
(<https://github.com/forestgeo/fgeo.abundance/issues/68>).
}

\examples{
tree <- fgeo.x::download_data("luquillo_tree5_random")

# Guess `plotdim`
abundance_neighbor(tree, r = 20)

# Explicit `plotdim`
abundance_neighbor(tree, r = 20, plotdim = c(320, 500))

basal_area_neighbor(tree, r = 20, plotdim = c(320, 500))

# Notice how the number of rows of the output varies with the input -------

tree <- tibble::tribble(
  ~treeID, ~stemID, ~gx, ~gy, ~tag,   ~sp,  ~dbh, ~status,
     "01",    "01",   5,   5, "01", "sp1",     5,     "A",
     "02",    "01",   5,   5, "02", "sp1",     5,     "A",
     "03",    "01",   5,   5, "03", "sp2",     5,     "A",
     "04",    "01",   5,   5, "04", "sp2",     5,     "A"
)

# ungrouped `.data`, `.subset = NULL`,
abundance_neighbor(tree, .subset = NULL, r = 20, plotdim = c(320, 500))

# grouped `.data`, `.subset = NULL`
by_sp <- dplyr::group_by(tree, sp)
abundance_neighbor(by_sp, .subset = NULL, r = 20, plotdim = c(320, 500))

subset <- tibble::tribble(
  ~gx, ~gy, ~tag,   ~sp,
    3,   3, "99", "sp1"
)

# ungrouped `.data`, `.subset` not `NULL`
abundance_neighbor(tree, .subset = subset, r = 20, plotdim = c(320, 500))

# grouped `.data`, `.subset` not `NULL`
by_sp <- dplyr::group_by(tree, sp)
abundance_neighbor(by_sp, .subset = subset, r = 20, plotdim = c(320, 500))
}
